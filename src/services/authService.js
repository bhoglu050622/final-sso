// Mock authentication service to simulate backend calls for Graphy SSO integration.
// TODO: Replace all functions with actual API calls to your backend when it's ready.

const MOCK_API_LATENCY = 500; // milliseconds

/**
 * Simulates generating an OTP for a given email.
 * In a real backend, this would trigger sending an OTP to the user's email.
 * @param {string} email - The user's email.
 * @returns {Promise<{success: boolean, message: string}>}
 */
export const generateOtp = (email) => {
  console.log(`[MockAuthService] generateOtp called for email: ${email}`);
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (!email || !email.includes('@')) {
        // console.error("[MockAuthService] Invalid email format for generateOtp");
        reject({ success: false, message: "Invalid email format." });
        return;
      }
      // Simulate success
      // console.log("[MockAuthService] Mock OTP generated successfully.");
      resolve({ success: true, message: "OTP generated and sent successfully (mocked)." });
    }, MOCK_API_LATENCY);
  });
};

/**
 * Simulates verifying an OTP.
 * In a real backend, this would validate the OTP and, if correct,
 * generate a JWT signed with the GRAPHY_API_TOKEN.
 * @param {string} email - The user's email.
 * @param {string} otp - The OTP entered by the user.
 * @returns {Promise<{success: boolean, ssoToken?: string, message: string}>}
 */
export const verifyOtp = (email, otp) => {
  console.log(`[MockAuthService] verifyOtp called for email: ${email}, otp: ${otp}`);
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (otp === "000000") { // Simulate an invalid OTP
        // console.warn("[MockAuthService] Invalid OTP entered (000000).");
        reject({ success: false, message: "Invalid or expired OTP (mocked error)." });
        return;
      }
      if (!otp || otp.length < 4) { // Basic validation
        // console.warn("[MockAuthService] OTP too short or missing.");
        reject({ success: false, message: "OTP is too short (mocked error)." });
        return;
      }

      // Simulate successful OTP verification and generate a dummy JWT
      // This dummy JWT is NOT cryptographically secure and is for frontend testing ONLY.
      // The real JWT MUST be generated by the backend using the Graphy API Token as the secret.
      const header = { alg: "HS256", typ: "JWT" };
      const payload = {
        email: email,
        name: "Mock User", // Optional: Add user's name
        exp: Math.floor(Date.now() / 1000) + (15 * 60), // Expires in 15 minutes
        // course_ids: ["course1", "course2"] // Optional: For auto-enrollment
      };
      // In a real scenario, the backend signs this. Here, we just create a plausible-looking fake.
      const dummyJwt = `dummy.${btoa(JSON.stringify(header))}.${btoa(JSON.stringify(payload))}.dummies`;

      // console.log("[MockAuthService] Mock OTP verified successfully. Generated dummy ssoToken:", dummyJwt);
      resolve({
        success: true,
        ssoToken: dummyJwt,
        message: "OTP verified successfully (mocked).",
      });
    }, MOCK_API_LATENCY);
  });
};

/**
 * Simulates exchanging an OAuth authorization code for a Graphy token.
 * In a real backend, this would involve a server-to-server call to Graphy's /sso/login endpoint.
 * @param {string} code - The authorization code from the OAuth provider (Google/GitHub).
 * @param {string} provider - The OAuth provider ('google' or 'github').
 * @returns {Promise<{success: boolean, token?: string, message: string, user?: object}>}
 */
export const exchangeCodeForToken = (code, provider) => {
  console.log(`[MockAuthService] exchangeCodeForToken called for provider: ${provider}, code: ${code}`);
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (!code || !provider) {
        // console.error("[MockAuthService] Missing code or provider for exchangeCodeForToken.");
        reject({ success: false, message: "Missing authorization code or provider (mocked error)." });
        return;
      }
      if (code === "error_code") { // Simulate an error during exchange
          // console.warn("[MockAuthService] Simulating error for code 'error_code'.");
          reject({ success: false, message: "Failed to exchange code with Graphy (mocked error)." });
          return;
      }

      // Simulate a successful exchange and return a dummy Graphy token
      // This dummy token is NOT a real Graphy token.
      const dummyGraphyToken = `graphy_dummy_token_${provider}_${Date.now()}`;
      const mockUser = {
        id: "mockUserId123",
        email: `mockuser_${provider}@example.com`,
        name: "Mock OAuth User",
      };

      // console.log("[MockAuthService] Mock code exchanged successfully. Generated dummy Graphy token:", dummyGraphyToken);
      resolve({
        success: true,
        token: dummyGraphyToken,
        user: mockUser,
        message: "OAuth flow successful (mocked). Token received.",
      });
    }, MOCK_API_LATENCY);
  });
};

// TODO: When backend is ready:
// 1. Remove all mock logic from these functions.
// 2. Implement actual `fetch` calls to your backend endpoints defined in `backend/API_DEFINITIONS.md`.
//    Example for verifyOtp:
//    const response = await fetch('/api/auth/otp/verify', {
//      method: 'POST',
//      headers: { 'Content-Type': 'application/json' },
//      body: JSON.stringify({ email, otp })
//    });
//    if (!response.ok) {
//      const errorData = await response.json();
//      throw new Error(errorData.message || 'OTP verification failed');
//    }
//    return await response.json(); // { success: true, ssoToken: "...", message: "..." }
// 3. Ensure proper error handling for network issues and API error responses.
// 4. Make sure the backend correctly handles secrets and signs JWTs as required.
